// Generated by CodiumAI

#include <gtest/gtest.h>
#include "HuffmanCompressor.h"


// Verify that a HuffmanNode is initialized with correct value and frequency
TEST(HuffmanNode, Initialization)
{
    HuffmanNode node(100, 5);
    ASSERT_EQ(node.value, 100);
    ASSERT_EQ(node.frequency, 5);
    ASSERT_EQ(node.left, nullptr);
    ASSERT_EQ(node.right, nullptr);
}

// Check that left and right children of a new HuffmanNode are initialized to nullptr
TEST(HuffmanNode, ChildrenInitialization) {
    HuffmanNode node(200, 10);
    ASSERT_EQ(node.left, nullptr);
    ASSERT_EQ(node.right, nullptr);
}

// Test HuffmanNode initialization with extreme frequency values (e.g., INT16_MAX, INT16_MIN)
TEST(HuffmanNode, ExtremeFrequencyValues) {
    HuffmanNode nodeMax(INT16_MAX, INT16_MAX);
    HuffmanNode nodeMin(INT16_MIN, INT16_MIN);
    ASSERT_EQ(nodeMax.value, INT16_MAX);
    ASSERT_EQ(nodeMax.frequency, INT16_MAX);
    ASSERT_EQ(nodeMin.value, INT16_MIN);
    ASSERT_EQ(nodeMin.frequency, INT16_MIN);
}

// Check behavior when HuffmanNode value is at the boundaries of int16_t (e.g., 32767, -32768)
TEST(HuffmanNode, BoundaryValue) {
    HuffmanNode nodeMax(32767, 100);
    HuffmanNode nodeMin(-32768, 100);
    ASSERT_EQ(nodeMax.value, 32767);
    ASSERT_EQ(nodeMin.value, -32768);
}

// Ensure that operator> handles nodes with equal frequency correctly
TEST(HuffmanNode, OperatorGreater) {
    HuffmanNode node1(100, 50);
    HuffmanNode node2(200, 50);
    ASSERT_FALSE(node1 > node2);
    ASSERT_FALSE(node2 > node1);
}


// Correctly builds codebook for a simple binary tree
TEST(HuffmanCodes, shouldGenerateCorrectCodebookForSimpleTree) {
    HuffmanNode leaf1(1, 1), leaf2(2, 1);
    std::shared_ptr<HuffmanNode> left(new HuffmanNode(1, 1));
    std::shared_ptr<HuffmanNode> right(new HuffmanNode(2, 1));
    HuffmanNode root(0, 2);
    root.left = left;
    root.right = right;

    HuffmanCodes coder;
    std::unordered_map<int16_t, std::string> codebook;
    coder.buildCodes(&root, "", codebook);

    ASSERT_EQ(codebook.size(), 2);
    ASSERT_EQ(codebook[1], "0");
    ASSERT_EQ(codebook[2], "1");
}

// Handles an empty tree where no codes are generated
TEST(HuffmanCodes, shouldHandleEmptyTreeWithoutGeneratingCodes) {
    HuffmanNode* root = nullptr;

    HuffmanCodes coder;
    std::unordered_map<int16_t, std::string> codebook;
    coder.buildCodes(root, "", codebook);

    ASSERT_TRUE(codebook.empty());
}

// Generates unique Huffman codes for each leaf node in the tree
TEST(HuffmanCodes, shouldGenerateUniqueCodesForEachLeaf) {
    HuffmanNode leaf1(1, 1), leaf2(2, 1);
    std::shared_ptr<HuffmanNode> left(new HuffmanNode(1, 1));
    std::shared_ptr<HuffmanNode> right(new HuffmanNode(2, 1));
    HuffmanNode root(0, 2);
    root.left = left;
    root.right = right;

    HuffmanCodes coder;
    std::unordered_map<int16_t, std::string> codebook;
    coder.buildCodes(&root, "", codebook);

    ASSERT_EQ(codebook.size(), 2);
    ASSERT_NE(codebook[1], codebook[2]);
}

// Recursively traverses left and right subtrees to build codes
TEST(HuffmanCodes, shouldTraverseSubtreesToBuildCodes) {
    HuffmanNode leaf1(1, 1), leaf2(2, 1), leaf3(3, 1);
    std::shared_ptr<HuffmanNode> left(new HuffmanNode(0, 2));
    left->left = std::make_shared<HuffmanNode>(leaf1);
    left->right = std::make_shared<HuffmanNode>(leaf2);
    std::shared_ptr<HuffmanNode> right(new HuffmanNode(3, 1));
    HuffmanNode root(0, 3);
    root.left = left;
    root.right = right;

    HuffmanCodes coder;
    std::unordered_map<int16_t, std::string> codebook;
    coder.buildCodes(&root, "", codebook);

    ASSERT_EQ(codebook.size(), 3);
    ASSERT_EQ(codebook[1], "00");
    ASSERT_EQ(codebook[2], "01");
    ASSERT_EQ(codebook[3], "1");
}

// Correctly handles a tree with only one node
TEST(HuffmanCodes, shouldHandleSingleNodeTree) {
    HuffmanNode leaf(1, 1);

    HuffmanCodes coder;
    std::unordered_map<int16_t, std::string> codebook;
    coder.buildCodes(&leaf, "", codebook);

    ASSERT_EQ(codebook.size(), 1);
    ASSERT_EQ(codebook[1], "");
}

// Correctly handles a tree with multiple levels
TEST(HuffmanCodes, shouldHandleMultiLevelTree) {
    HuffmanNode leaf1(1, 1), leaf2(2, 1), leaf3(3, 1), leaf4(4, 1);
    std::shared_ptr<HuffmanNode> left1(new HuffmanNode(0, 3));
    left1->left = std::make_shared<HuffmanNode>(leaf1);
    left1->right = std::make_shared<HuffmanNode>(leaf2);
    std::shared_ptr<HuffmanNode> right1(new HuffmanNode(0, 2));
    right1->left = std::make_shared<HuffmanNode>(leaf3);
    right1->right = std::make_shared<HuffmanNode>(leaf4);
    HuffmanNode root(0, 5);
    root.left = left1;
    root.right = right1;

    HuffmanCodes coder;
    std::unordered_map<int16_t, std::string> codebook;
    coder.buildCodes(&root, "", codebook);

    ASSERT_EQ(codebook.size(), 4);
    ASSERT_EQ(codebook[1], "00");
    ASSERT_EQ(codebook[2], "01");
    ASSERT_EQ(codebook[3], "10");
    ASSERT_EQ(codebook[4], "11");
}

    // Verify tree builds correctly from a frequency table with multiple unique frequencies
    TEST(HuffmanTree, shouldBuildCorrectTreeFromMultipleUniqueFrequencies) {
        std::unordered_map<int16_t, int> frequencies = {{1, 5}, {2, 3}, {3, 8}};
        HuffmanTree treeBuilder;
        auto root = treeBuilder.buildTree(frequencies);
        ASSERT_NE(root, nullptr);
        ASSERT_EQ(root->frequency, 16);
    }

    // Ensure single node tree is created when only one unique frequency is provided
    TEST(HuffmanTree, shouldCreateSingleNodeTreeFromSingleFrequency) {
        std::unordered_map<int16_t, int> frequencies = {{1, 10}};
        HuffmanTree treeBuilder;
        auto root = treeBuilder.buildTree(frequencies);
        ASSERT_NE(root, nullptr);
        ASSERT_EQ(root->value, 1);
        ASSERT_EQ(root->frequency, 10);
    }

    // Handle an empty frequency table and return null or an appropriate response
    TEST(HuffmanTree, shouldHandleEmptyFrequencyTable) {
        std::unordered_map<int16_t, int> frequencies;
        HuffmanTree treeBuilder;
        auto root = treeBuilder.buildTree(frequencies);
        ASSERT_EQ(root, nullptr);
    }

    // Process frequency table with all identical frequencies correctly
    TEST(HuffmanTree, shouldBuildCorrectTreeFromIdenticalFrequencies) {
        std::unordered_map<int16_t, int> frequencies = {{1, 4}, {2, 4}, {3, 4}};
        HuffmanTree treeBuilder;
        auto root = treeBuilder.buildTree(frequencies);
        ASSERT_NE(root, nullptr);
        ASSERT_EQ(root->frequency, 12);
    }

    // Build tree correctly when frequency table contains negative values as keys
    TEST(HuffmanTree, shouldBuildTreeWithNegativeValuesAsKeys) {
        std::unordered_map<int16_t, int> frequencies = {{-1, 3}, {-2, 5}, {-3, 2}};
        HuffmanTree treeBuilder;
        auto root = treeBuilder.buildTree(frequencies);
        ASSERT_NE(root, nullptr);
        ASSERT_EQ(root->frequency, 10);
    }

    // Verify that the function correctly computes frequency of each unique value
    TEST(Compress, FrequencyComputation) {
        HuffmanCompressor compressor;
        std::vector<int16_t> data = {1, 2, 2, 3, 3, 3};
        auto compressed = compressor.compress(data);

        // Build the Huffman tree again to get the root for decompression
        std::unordered_map<int16_t, int> frequencies;
        for (int16_t value : data) {
            frequencies[value]++;
        }
        HuffmanTree treeBuilder;
        std::shared_ptr<HuffmanNode> root = treeBuilder.buildTree(frequencies);

        // Decompress the data
        auto decompressed = compressor.decompress(compressed, root.get(), data.size());

        // Check if the decompressed data matches the original data
        ASSERT_EQ(decompressed, data);
    }

    // Check that Huffman tree is built correctly from frequency data
    TEST(Compress, TreeConstruction) {
        HuffmanCompressor compressor;
        std::vector<int16_t> data = {4, 4, 4, 5, 5, 6};
        auto compressed = compressor.compress(data);
        ASSERT_NE(compressed.size(), 0); // Simplified check for non-empty output indicating tree was built
    }

    // Test to verify correct Huffman tree construction from a frequency table and ensure no extra nodes
TEST(HuffmanTree, shouldBuildCorrectTreeAndVerifyStructureWithNoExtraNodes) {
    std::unordered_map<int16_t, int> frequencies = {{'A', 2}, {'B', 2}};
    HuffmanTree treeBuilder;
    auto root = treeBuilder.buildTree(frequencies);

    // Check if the root node is correctly set
    ASSERT_NE(root, nullptr);
    ASSERT_EQ(root->frequency, 4); // Total frequency should be sum of frequencies

    // Check structure of the tree: root should have two children with correct values and frequencies
    ASSERT_NE(root->left, nullptr);
    ASSERT_NE(root->right, nullptr);

    // Verify that the children of the root are leaf nodes (no further children)
    ASSERT_EQ(root->left->left, nullptr);
    ASSERT_EQ(root->left->right, nullptr);
    ASSERT_EQ(root->right->left, nullptr);
    ASSERT_EQ(root->right->right, nullptr);

    // Since the order of left and right can vary depending on the implementation details,
    // we check for both possibilities (A on left or right)
    if (root->left->value == 'A' && root->right->value == 'B') {
        ASSERT_EQ(root->left->frequency, 2);
        ASSERT_EQ(root->right->frequency, 2);
    } else if (root->left->value == 'B' && root->right->value == 'A') {
        ASSERT_EQ(root->left->frequency, 2);
        ASSERT_EQ(root->right->frequency, 2);
    } else {
        FAIL() << "Tree structure incorrect: children nodes do not have expected values";
    }
}

    // Test with an empty input vector to see if it gracefully returns an empty compressed data vector
    TEST(Compress, EmptyInput) {
        HuffmanCompressor compressor;
        std::vector<int16_t> data = {};
        auto compressed = compressor.compress(data);
        ASSERT_TRUE(compressed.empty());
    }

    // Test with input data having all identical values to check if compression is effective
    TEST(Compress, IdenticalValues) {
        HuffmanCompressor compressor;
        std::vector<int16_t> data = {7, 7, 7, 7, 7};
        auto compressed = compressor.compress(data);
        ASSERT_LT(compressed.size(), data.size()); // Check if compressed size is less than original
    }

    // Test with input data having maximum possible int16_t values to ensure correct frequency calculation and compression
    TEST(Compress, MaxIntValues) {
        HuffmanCompressor compressor;
        std::vector<int16_t> data = {INT16_MAX, INT16_MAX, INT16_MAX};
        auto compressed = compressor.compress(data);
        ASSERT_LT(compressed.size(), data.size()); // Check if compression reduces size for max int values
}

#include <iostream>

void printCompressedData(const std::vector<uint8_t>& compressedData) {
    std::cout << "Compressed Data: ";
    for (auto byte : compressedData) {
        std::cout << static_cast<int>(byte) << " ";
    }
    std::cout << std::endl;
}

void printHuffmanTree(const std::shared_ptr<HuffmanNode>& node, const std::string& prefix = "") {
    if (!node) return;
    std::cout << prefix << "Node(value: " << node->value << ", frequency: " << node->frequency << ")" << std::endl;
    if (node->left) {
        printHuffmanTree(node->left, prefix + "  ");
    }
    if (node->right) {
        printHuffmanTree(node->right, prefix + "  ");
    }
}

TEST(HuffmanCompressorTest, BasicDecompression) {
    HuffmanCompressor compressor;
    HuffmanTree treeBuilder;
    HuffmanCodes codeBuilder;

    // Original data
    std::vector<int16_t> data = {'A', 'B', 'A', 'B'};

    // Compress the data
    auto compressedData = compressor.compress(data);
    printCompressedData(compressedData);

    // Build the Huffman Tree from the frequency table
    std::unordered_map<int16_t, int> frequencies = {{'A', 2}, {'B', 2}};
    auto root = treeBuilder.buildTree(frequencies);
    printHuffmanTree(root);

    // Decompress the data
    auto decompressedData = compressor.decompress(compressedData, root.get(), data.size());
    std::cout << "Decompressed Data: ";
    for (auto val : decompressedData) {
        std::cout << static_cast<char>(val) << " ";
    }
    std::cout << std::endl;

    // Verify the decompressed data matches the original data
    EXPECT_EQ(decompressedData, data);
}

TEST(HuffmanCompressorTest, MoreComplexDecompression) {
    HuffmanCompressor compressor;
    HuffmanTree treeBuilder;
    HuffmanCodes codeBuilder;

    // Original data
    std::vector<int16_t> data = {'A', 'B', 'A', 'B', 'A', 'B', 'A', 'B', 123, 456, 123, 123, 1, 9999};

    // Compress the data
    auto compressedData = compressor.compress(data);
    printCompressedData(compressedData);

    // // Build the Huffman Tree from the frequency table
    // std::unordered_map<int16_t, int> frequencies;
    // for (int16_t value : data) {
    //     frequencies[value]++;
    // }
    // auto root = treeBuilder.buildTree(frequencies);
    // printHuffmanTree(root);

    // Decompress the data
    auto decompressedData = compressor.decompress(compressedData, data.size());
    std::cout << "Decompressed Data: ";
    for (auto val : decompressedData) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    // Verify the decompressed data matches the original data
    EXPECT_EQ(decompressedData, data);
}
